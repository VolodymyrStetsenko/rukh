"""
RUKH Exploit Generator
Automatically generates exploit tests from vulnerability reports
Author: Volodymyr Stetsenko (Zero2Auditor)
"""

import os
import json
import re
from typing import List, Dict, Optional
from dataclasses import dataclass


@dataclass
class ExploitTemplate:
    """Exploit template configuration"""
    vulnerability_type: str
    template_path: str
    severity: str
    complexity: str


class ExploitGenerator:
    """Generates exploit tests from vulnerability data"""
    
    def __init__(self, templates_dir: str = "./templates/poc-library"):
        self.templates_dir = templates_dir
        self.templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, ExploitTemplate]:
        """Load available exploit templates"""
        templates = {
            'reentrancy': ExploitTemplate(
                vulnerability_type='reentrancy',
                template_path=f'{self.templates_dir}/reentrancy/ReentrancyPoC.sol',
                severity='high',
                complexity='medium'
            ),
            'flash-loan': ExploitTemplate(
                vulnerability_type='flash-loan',
                template_path=f'{self.templates_dir}/flash-loan/FlashLoanPoC.sol',
                severity='critical',
                complexity='high'
            ),
            'access-control': ExploitTemplate(
                vulnerability_type='access-control',
                template_path=f'{self.templates_dir}/access-control/AccessControlPoC.sol',
                severity='high',
                complexity='low'
            ),
        }
        return templates
    
    def generate_exploit(
        self,
        vulnerability: Dict,
        contract_name: str,
        contract_path: str,
        output_dir: str
    ) -> str:
        """Generate exploit test for a vulnerability"""
        
        vuln_type = self._identify_vulnerability_type(vulnerability)
        
        if vuln_type not in self.templates:
            print(f"[!] No template for vulnerability type: {vuln_type}")
            return None
        
        template = self.templates[vuln_type]
        
        # Load template
        if os.path.exists(template.template_path):
            with open(template.template_path, 'r') as f:
                template_code = f.read()
        else:
            template_code = self._generate_basic_template(vuln_type)
        
        # Customize template
        exploit_code = self._customize_template(
            template_code,
            vulnerability,
            contract_name,
            contract_path
        )
        
        # Save exploit
        os.makedirs(output_dir, exist_ok=True)
        output_path = os.path.join(
            output_dir,
            f"Exploit_{contract_name}_{vuln_type}.t.sol"
        )
        
        with open(output_path, 'w') as f:
            f.write(exploit_code)
        
        print(f"[+] Generated exploit: {output_path}")
        return output_path
    
    def _identify_vulnerability_type(self, vulnerability: Dict) -> str:
        """Identify vulnerability type from Slither output"""
        check = vulnerability.get('check', '').lower()
        description = vulnerability.get('description', '').lower()
        
        # Reentrancy patterns
        if 'reentrancy' in check or 'reentrancy' in description:
            return 'reentrancy'
        
        # Access control patterns
        if any(keyword in check or keyword in description for keyword in 
               ['access-control', 'unprotected', 'missing-modifier', 'tx-origin']):
            return 'access-control'
        
        # Arithmetic patterns
        if any(keyword in check or keyword in description for keyword in
               ['overflow', 'underflow', 'division', 'arithmetic']):
            return 'arithmetic'
        
        # Delegatecall patterns
        if 'delegatecall' in check or 'delegatecall' in description:
            return 'delegatecall'
        
        # Default to generic
        return 'generic'
    
    def _customize_template(
        self,
        template_code: str,
        vulnerability: Dict,
        contract_name: str,
        contract_path: str
    ) -> str:
        """Customize template with specific vulnerability details"""
        
        # Replace contract name
        code = template_code.replace('VulnerableContract', contract_name)
        code = code.replace('TARGET_CONTRACT', contract_name)
        
        # Replace contract path
        code = code.replace('TARGET_PATH', contract_path)
        
        # Add vulnerability-specific details
        vuln_description = vulnerability.get('description', 'No description')
        vuln_location = self._extract_location(vulnerability)
        
        # Add comment with vulnerability details
        details_comment = f"""
/**
 * VULNERABILITY DETAILS:
 * Type: {vulnerability.get('check', 'Unknown')}
 * Severity: {vulnerability.get('impact', 'Unknown')}
 * Confidence: {vulnerability.get('confidence', 'Unknown')}
 * Location: {vuln_location}
 * Description: {vuln_description}
 */
"""
        
        # Insert details after SPDX license
        code = code.replace(
            '// SPDX-License-Identifier: MIT',
            f'// SPDX-License-Identifier: MIT\n{details_comment}'
        )
        
        # Extract function name if available
        function_name = self._extract_function_name(vulnerability)
        if function_name:
            code = code.replace('vulnerableFunction', function_name)
        
        return code
    
    def _extract_location(self, vulnerability: Dict) -> str:
        """Extract location from vulnerability data"""
        elements = vulnerability.get('elements', [])
        if elements and len(elements) > 0:
            first_element = elements[0]
            source_mapping = first_element.get('source_mapping', {})
            filename = source_mapping.get('filename_short', 'Unknown')
            lines = source_mapping.get('lines', [])
            if lines:
                return f"{filename}:L{lines[0]}"
        return "Unknown"
    
    def _extract_function_name(self, vulnerability: Dict) -> Optional[str]:
        """Extract function name from vulnerability data"""
        elements = vulnerability.get('elements', [])
        for element in elements:
            if element.get('type') == 'function':
                return element.get('name')
        return None
    
    def _generate_basic_template(self, vuln_type: str) -> str:
        """Generate basic template if specific template not found"""
        return f"""// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {{Test}} from "forge-std/Test.sol";
import {{console}} from "forge-std/console.sol";

/**
 * @title {vuln_type.title()} Exploit
 * @author Volodymyr Stetsenko (Zero2Auditor)
 */
contract {vuln_type.title().replace('-', '')}Exploit is Test {{
    address public target;
    address public attacker = address(0x1337);
    
    function setUp() public {{
        // TODO: Deploy target contract
        vm.deal(attacker, 100 ether);
    }}
    
    function test_exploit() public {{
        vm.startPrank(attacker);
        
        // TODO: Implement exploit logic
        
        vm.stopPrank();
    }}
}}
"""
    
    def generate_batch_exploits(
        self,
        vulnerabilities_file: str,
        contract_name: str,
        contract_path: str,
        output_dir: str
    ) -> List[str]:
        """Generate exploits for all vulnerabilities in a file"""
        
        with open(vulnerabilities_file, 'r') as f:
            vulnerabilities = json.load(f)
        
        generated_exploits = []
        
        for vuln in vulnerabilities:
            exploit_path = self.generate_exploit(
                vuln,
                contract_name,
                contract_path,
                output_dir
            )
            if exploit_path:
                generated_exploits.append(exploit_path)
        
        print(f"\n[+] Generated {len(generated_exploits)} exploit tests")
        return generated_exploits
    
    def generate_master_test_suite(
        self,
        exploit_files: List[str],
        output_path: str
    ):
        """Generate master test suite that runs all exploits"""
        
        master_suite = """// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";

/**
 * @title Master Exploit Test Suite
 * @notice Runs all generated exploit tests
 * @author Volodymyr Stetsenko (Zero2Auditor)
 */
contract MasterExploitSuite is Test {
    function test_run_all_exploits() public {
        // This test suite aggregates all exploit tests
        // Run with: forge test --match-contract MasterExploitSuite -vvvv
    }
}
"""
        
        with open(output_path, 'w') as f:
            f.write(master_suite)
        
        print(f"[+] Generated master test suite: {output_path}")


def main():
    """CLI entry point"""
    import sys
    
    if len(sys.argv) < 5:
        print("""
Usage: python exploit_generator.py <vulnerabilities_json> <contract_name> <contract_path> <output_dir>

Examples:
  python exploit_generator.py slither-results.json MyContract src/MyContract.sol test/exploits/
  python exploit_generator.py vulnerabilities.json Vault contracts/Vault.sol test/
""")
        sys.exit(1)
    
    vulnerabilities_file = sys.argv[1]
    contract_name = sys.argv[2]
    contract_path = sys.argv[3]
    output_dir = sys.argv[4]
    
    generator = ExploitGenerator()
    
    # Generate exploits
    exploit_files = generator.generate_batch_exploits(
        vulnerabilities_file,
        contract_name,
        contract_path,
        output_dir
    )
    
    # Generate master suite
    if exploit_files:
        master_path = os.path.join(output_dir, "MasterExploitSuite.t.sol")
        generator.generate_master_test_suite(exploit_files, master_path)
    
    print("\n[✓] Exploit generation complete!")
    print(f"[✓] Run tests with: forge test --match-path {output_dir}/*.sol -vvvv")


if __name__ == "__main__":
    main()

